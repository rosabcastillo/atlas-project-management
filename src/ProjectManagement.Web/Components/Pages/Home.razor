@page "/"
@using Microsoft.EntityFrameworkCore
@using ProjectManagement.Infrastructure.Data
@inject AppDbContext DbContext
@rendermode InteractiveServer

<PageTitle>Dashboard - Nova</PageTitle>

<div class="page-header">
    <div>
        <h1 class="page-title">Dashboard</h1>
        <p class="page-subtitle">Overview of your project and resource allocations</p>
    </div>
</div>

<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-icon purple">üìÅ</div>
        <div class="stat-content">
            <div class="stat-value">@projectCount</div>
            <div class="stat-label">Total Projects</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-icon blue">üë•</div>
        <div class="stat-content">
            <div class="stat-value">@resourceCount</div>
            <div class="stat-label">Total Resources</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-icon green">üìÖ</div>
        <div class="stat-content">
            <div class="stat-value">@allocationCount</div>
            <div class="stat-label">Active Allocations</div>
        </div>
    </div>
    <div class="stat-card">
        <div class="stat-icon orange">‚ö†Ô∏è</div>
        <div class="stat-content">
            <div class="stat-value">@overAllocatedCount</div>
            <div class="stat-label">Over-allocated</div>
        </div>
    </div>
</div>

<div class="glass-card">
    <div class="glass-card-header">
        <h3 class="glass-card-title">Resources by Role</h3>
    </div>
    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th>Role</th>
                    <th>Count</th>
                    <th>Requires Capacity</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var item in resourcesByRole)
                {
                    <tr>
                        <td><strong>@item.RoleName</strong></td>
                        <td>@item.Count</td>
                        <td>
                            @if (item.RequiresCapacity)
                            {
                                <span class="badge badge-primary">Yes</span>
                            }
                            else
                            {
                                <span class="badge badge-secondary">No</span>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
</div>

<div class="glass-card">
    <div class="glass-card-header">
        <h3 class="glass-card-title">Recent Projects</h3>
        <a href="projects" class="btn btn-secondary btn-sm">View All</a>
    </div>
    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th>Project Name</th>
                    <th>Accountable Lead</th>
                    <th>Delivery Method</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var project in recentProjects)
                {
                    <tr>
                        <td><strong>@project.Name</strong></td>
                        <td>@(project.AccountableLead ?? "-")</td>
                        <td>
                            @if (project.DeliveryMethod.HasValue)
                            {
                                <span class="badge badge-primary">@project.DeliveryMethod</span>
                            }
                            else
                            {
                                <span class="badge badge-secondary">Not set</span>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
</div>

@code {
    private int projectCount;
    private int resourceCount;
    private int allocationCount;
    private int overAllocatedCount;
    private List<ResourceByRole> resourcesByRole = new();
    private List<ProjectManagement.Domain.Entities.Project> recentProjects = new();

    protected override async Task OnInitializedAsync()
    {
        projectCount = await DbContext.Projects.CountAsync();
        resourceCount = await DbContext.Resources.CountAsync();
        allocationCount = await DbContext.Allocations.CountAsync();

        resourcesByRole = await DbContext.Roles
            .Select(r => new ResourceByRole
            {
                RoleName = r.Name,
                Count = r.ResourceRoles.Count,
                RequiresCapacity = r.RequiresCapacity
            })
            .ToListAsync();

        recentProjects = await DbContext.Projects
            .OrderByDescending(p => p.CreatedAt)
            .Take(5)
            .ToListAsync();

        // Calculate over-allocated (resources with >100% allocation in any overlapping period)
        var resourcesWithCapacity = await DbContext.Resources
            .Include(r => r.ResourceRoles).ThenInclude(rr => rr.Role)
            .Include(r => r.Allocations)
            .Where(r => r.ResourceRoles.Any(rr => rr.Role.RequiresCapacity))
            .ToListAsync();

        foreach (var resource in resourcesWithCapacity)
        {
            var allocations = resource.Allocations.Where(a => a.Percentage.HasValue).ToList();
            if (!allocations.Any()) continue;

            // Find all date boundaries
            var boundaries = new HashSet<DateTime>();
            foreach (var alloc in allocations)
            {
                boundaries.Add(alloc.StartDate);
                boundaries.Add(alloc.EndDate);
            }

            var sortedBoundaries = boundaries.OrderBy(d => d).ToList();

            // Check each period between boundaries for over-allocation
            for (int i = 0; i < sortedBoundaries.Count - 1; i++)
            {
                var periodStart = sortedBoundaries[i];
                var periodEnd = sortedBoundaries[i + 1];
                var midPoint = periodStart.AddDays((periodEnd - periodStart).TotalDays / 2);

                var periodTotal = allocations
                    .Where(a => a.StartDate <= midPoint && a.EndDate >= midPoint)
                    .Sum(a => a.Percentage ?? 0);

                if (periodTotal > 100)
                {
                    overAllocatedCount++;
                    break; // Count each resource only once
                }
            }
        }
    }

    private class ResourceByRole
    {
        public string RoleName { get; set; } = "";
        public int Count { get; set; }
        public bool RequiresCapacity { get; set; }
    }
}
