@page "/settings/roles"
@using Microsoft.EntityFrameworkCore
@using ProjectManagement.Infrastructure.Data
@using ProjectManagement.Domain.Entities
@inject AppDbContext DbContext
@rendermode InteractiveServer

<PageTitle>Roles - Settings</PageTitle>

<div class="page-header">
    <div>
        <h1 class="page-title">Roles</h1>
        <p class="page-subtitle">Manage resource roles and capacity requirements</p>
    </div>
    <button class="btn btn-primary" @onclick="OpenAddModal">+ Add Role</button>
</div>

<div class="glass-card">
    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th class="sortable @(GetSortClass("Name"))" @onclick='() => SetSort("Name")' aria-sort="@(DisplayHelpers.GetAriaSort(sortColumn, sortAscending, "Name"))">Role Name</th>
                    <th class="sortable @(GetSortClass("Capacity"))" @onclick='() => SetSort("Capacity")' aria-sort="@(DisplayHelpers.GetAriaSort(sortColumn, sortAscending, "Capacity"))">Requires Capacity</th>
                    <th class="sortable @(GetSortClass("Resources"))" @onclick='() => SetSort("Resources")' aria-sort="@(DisplayHelpers.GetAriaSort(sortColumn, sortAscending, "Resources"))">Resources</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var role in PagedRoles)
                {
                    <tr>
                        <td><strong>@role.Name</strong></td>
                        <td>
                            @if (role.RequiresCapacity)
                            {
                                <span class="badge badge-primary">Yes (tracked at 100%)</span>
                            }
                            else
                            {
                                <span class="badge badge-secondary">No</span>
                            }
                        </td>
                        <td>@role.ResourceRoles.Count</td>
                        <td>
                            <button class="btn btn-secondary btn-sm" @onclick="() => OpenEditModal(role)">Edit</button>
                            @if (role.ResourceRoles.Count == 0)
                            {
                                <button class="btn btn-danger btn-sm" @onclick="() => ConfirmDelete(role)">Delete</button>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>

    <PaginationBar CurrentPage="currentPage" PageSize="pageSize" TotalCount="TotalCount" OnPageChanged="GoToPage" />
</div>

@if (showModal)
{
    <div class="modal-backdrop" @onclick="CloseModal">
        <div class="modal" @onclick:stopPropagation="true" role="dialog" aria-labelledby="modal-title-role">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title-role">@(isEditing ? "Edit Role" : "Add Role")</h3>
                <button class="modal-close" @onclick="CloseModal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Role Name *</label>
                    <input type="text" class="form-control" @bind="currentRole.Name" />
                    @if (!string.IsNullOrEmpty(roleError))
                    {
                        <div class="text-danger field-validation-error">@roleError</div>
                    }
                </div>
                <div class="form-group">
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="requiresCapacity" @bind="currentRole.RequiresCapacity" />
                        <label for="requiresCapacity">Requires Capacity Tracking (100% limit)</label>
                    </div>
                    <p class="page-subtitle" style="margin-top: 0.5rem; font-size: 0.75rem;">
                        Enable this for roles like Developer and QA where allocation should not exceed 100%.
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CloseModal">Cancel</button>
                <button class="btn btn-primary" @onclick="SaveRole">Save</button>
            </div>
        </div>
    </div>
}

<ConfirmDeleteModal Visible="showDeleteConfirm"
    Message="@($"Are you sure you want to delete role \"{roleToDelete?.Name}\"?")"
    OnConfirm="DeleteRole"
    OnCancel="CancelDelete" />

@code {
    private List<Role> roles = new();
    private bool showModal = false;
    private bool isEditing = false;
    private Role currentRole = new();
    private string? roleError = null;
    private bool showDeleteConfirm = false;
    private Role? roleToDelete = null;

    // Pagination & Sorting
    private int currentPage = 1;
    private int pageSize = 10;
    private string sortColumn = "Name";
    private bool sortAscending = true;

    private IEnumerable<Role> SortedRoles
    {
        get
        {
            return sortColumn switch
            {
                "Name" => sortAscending ? roles.OrderBy(r => r.Name) : roles.OrderByDescending(r => r.Name),
                "Capacity" => sortAscending ? roles.OrderBy(r => r.RequiresCapacity) : roles.OrderByDescending(r => r.RequiresCapacity),
                "Resources" => sortAscending ? roles.OrderBy(r => r.ResourceRoles.Count) : roles.OrderByDescending(r => r.ResourceRoles.Count),
                _ => roles.OrderBy(r => r.Name)
            };
        }
    }

    private IEnumerable<Role> PagedRoles => SortedRoles.Skip((currentPage - 1) * pageSize).Take(pageSize);
    private int TotalCount => roles.Count;

    private void GoToPage(int pg) => currentPage = pg;

    private void SetSort(string column)
    {
        if (sortColumn == column)
            sortAscending = !sortAscending;
        else
        {
            sortColumn = column;
            sortAscending = true;
        }
        currentPage = 1;
    }

    private string GetSortClass(string column) => sortColumn == column ? (sortAscending ? "asc" : "desc") : "";

    protected override async Task OnInitializedAsync()
    {
        await LoadRoles();
    }

    private async Task LoadRoles()
    {
        roles = await DbContext.Roles.Include(r => r.ResourceRoles).OrderBy(r => r.Name).ToListAsync();
    }

    private void OpenAddModal()
    {
        currentRole = new Role();
        isEditing = false;
        roleError = null;
        showModal = true;
    }

    private void OpenEditModal(Role role)
    {
        currentRole = new Role { Id = role.Id, Name = role.Name, RequiresCapacity = role.RequiresCapacity };
        isEditing = true;
        roleError = null;
        showModal = true;
    }

    private void CloseModal() { roleError = null; showModal = false; }

    private async Task SaveRole()
    {
        roleError = null;
        if (string.IsNullOrWhiteSpace(currentRole.Name)) return;

        var nameToCheck = currentRole.Name.Trim().ToLower();
        var duplicate = await DbContext.Roles
            .AnyAsync(r => r.Name.ToLower() == nameToCheck && (!isEditing || r.Id != currentRole.Id));
        if (duplicate)
        {
            roleError = "A role with this name already exists.";
            return;
        }

        if (isEditing)
        {
            var existing = await DbContext.Roles.FindAsync(currentRole.Id);
            if (existing != null)
            {
                existing.Name = currentRole.Name;
                existing.RequiresCapacity = currentRole.RequiresCapacity;
                await DbContext.SaveChangesAsync();
            }
        }
        else
        {
            DbContext.Roles.Add(currentRole);
            await DbContext.SaveChangesAsync();
        }

        await LoadRoles();
        CloseModal();
    }

    private void ConfirmDelete(Role role)
    {
        roleToDelete = role;
        showDeleteConfirm = true;
    }

    private void CancelDelete()
    {
        roleToDelete = null;
        showDeleteConfirm = false;
    }

    private async Task DeleteRole()
    {
        if (roleToDelete == null) return;
        DbContext.Roles.Remove(roleToDelete);
        await DbContext.SaveChangesAsync();
        roleToDelete = null;
        showDeleteConfirm = false;
        await LoadRoles();
    }
}
