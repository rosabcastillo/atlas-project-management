@page "/allocations"
@using Microsoft.EntityFrameworkCore
@using ProjectManagement.Infrastructure.Data
@using ProjectManagement.Domain.Entities
@using ProjectManagement.Application.Services
@using ProjectManagement.Application.DTOs
@inject AppDbContext DbContext
@inject AllocationService AllocationService
@rendermode InteractiveServer

<PageTitle>Allocations - Nova</PageTitle>

<div class="page-header">
    <div>
        <h1 class="page-title">Allocations</h1>
        <p class="page-subtitle">Manage resource allocations across projects</p>
    </div>
    <button class="btn btn-primary" @onclick="OpenAddModal"><i class="icon-plus"></i> Add Allocation</button>
</div>

<div class="glass-card">
    <div class="action-bar">
        <div class="action-bar-left">
            <div class="search-box">
                <input type="text" class="form-control" placeholder="Search resources..." @bind="searchTerm" @bind:event="oninput" />
            </div>
            <div class="date-filter">
                <label>From:</label>
                <input type="date" class="form-control w-auto" @bind="filterStartDate" />
            </div>
            <div class="date-filter">
                <label>To:</label>
                <input type="date" class="form-control w-auto" @bind="filterEndDate" />
            </div>
            <select class="form-control w-auto-sm" @bind="selectedRoleId" @bind:after="OnFilterChanged">
                <option value="0">All Roles</option>
                @foreach (var role in roles)
                {
                    <option value="@role.Id">@role.Name</option>
                }
            </select>
        </div>
        <div class="action-bar-right">
            <button class="btn btn-secondary btn-sm" style="white-space: nowrap;" @onclick="ToggleExpandAll" aria-label="@(allExpanded ? "Collapse All" : "Expand All")">
                @(allExpanded ? "▲ Collapse All" : "▼ Expand All")
            </button>
        </div>
    </div>

    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th class="sortable @(GetSortClass("Resource"))" @onclick='() => SetSort("Resource")' aria-sort="@(DisplayHelpers.GetAriaSort(sortColumn, sortAscending, "Resource"))">Resource</th>
                    <th class="sortable @(GetSortClass("Role"))" @onclick='() => SetSort("Role")' aria-sort="@(DisplayHelpers.GetAriaSort(sortColumn, sortAscending, "Role"))">Role</th>
                    <th>Max Allocation</th>
                    <th>Allocations</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var resource in SortedResources)
                {
                    var resourceAllocations = GetResourceAllocations(resource.Id);
                    var hasAllocations = resourceAllocations.Any();
                    var isExpanded = expandedResources.Contains(resource.Id);
                    var isTerminated = resource.EndDate.HasValue && resource.EndDate.Value < DateTime.Today;

                    <tr class="@(hasAllocations ? "resource-expandable" : "") @(isTerminated ? "row-terminated" : "")">
                        <td>
                            @if (hasAllocations)
                            {
                                <button class="expand-btn" @onclick="() => ToggleResource(resource.Id)" aria-expanded="@isExpanded" aria-label="@(isExpanded ? "Collapse" : "Expand") allocations for @resource.Name">
                                    @(isExpanded ? "▼" : "▶")
                                </button>
                            }
                            else
                            {
                                <span class="expand-placeholder"></span>
                            }
                            <strong>@resource.Name</strong>
                            @if (isTerminated)
                            {
                                <span class="badge badge-danger ms-2">Terminated</span>
                            }
                        </td>
                        <td>
                            <div class="skill-tags">
                                @foreach (var rr in resource.ResourceRoles)
                                {
                                    <span class="badge @(rr.Role.RequiresCapacity ? "badge-primary" : "badge-secondary")">
                                        @rr.Role.Name
                                    </span>
                                }
                            </div>
                        </td>
                        <td>
                            @if (resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity))
                            {
                                var maxOverlap = GetMaxOverlapAllocation(resource.Id);
                                var hasOverlap = HasOverlappingDates(resource.Id);
                                <div class="allocation-bar-container">
                                    <div class="allocation-bar">
                                        <div class="allocation-bar-fill @GetAllocationClass(maxOverlap)"
                                             style="width: @Math.Min(maxOverlap, 100)%"></div>
                                    </div>
                                    <span class="allocation-text @(maxOverlap > 100 ? "danger" : "")">
                                        @maxOverlap%
                                        @if (hasOverlap)
                                        {
                                            <span class="overlap-indicator" title="Has overlapping date ranges"><i class="icon-alert-triangle"></i></span>
                                        }
                                    </span>
                                </div>
                            }
                            else
                            {
                                <span class="badge badge-secondary">N/A</span>
                            }
                        </td>
                        <td>
                            <span class="project-count">@resourceAllocations.Count() allocation(s)</span>
                        </td>
                        <td>
                            @if (!isTerminated)
                            {
                                <button class="btn btn-primary btn-sm" @onclick="() => OpenAddModalForResource(resource)"><i class="icon-plus"></i> Allocate</button>
                            }
                        </td>
                    </tr>
                    @if (isExpanded && hasAllocations)
                    {
                        <tr class="allocation-panel-row">
                            <td colspan="5">
                                <div class="allocation-panel">
                                    <div class="allocation-list">
                                        @foreach (var allocation in resourceAllocations.OrderBy(a => a.StartDate).ThenBy(a => a.Project.Name))
                                        {
                                            var hasDateOverlap = GetOverlappingAllocationsCount(allocation) > 0;
                                            <div class="allocation-item @(hasDateOverlap ? "has-overlap" : "")">
                                                <div class="allocation-item-info">
                                                    <span class="allocation-project">@allocation.Project.Name</span>
                                                    <span class="allocation-dates">
                                                        @allocation.StartDate.ToString("MMM dd, yyyy") - @allocation.EndDate.ToString("MMM dd, yyyy")
                                                    </span>
                                                    @if (hasDateOverlap)
                                                    {
                                                        <span class="overlap-badge" title="Overlaps with @GetOverlappingAllocationsCount(allocation) other allocation(s)"><i class="icon-alert-triangle"></i> Overlap</span>
                                                    }
                                                </div>
                                                <div class="allocation-item-actions">
                                                    @if (resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity))
                                                    {
                                                        <span class="allocation-percentage-badge">@(allocation.Percentage ?? 0)%</span>
                                                    }
                                                    <button class="btn-icon-action" data-tooltip="Edit" @onclick="() => OpenEditModal(allocation)"><i class="icon-pencil"></i></button>
                                                    <button class="btn-icon-action danger" data-tooltip="Delete" @onclick="() => ConfirmDelete(allocation)"><i class="icon-trash-2"></i></button>
                                                </div>
                                            </div>
                                        }
                                    </div>
                                </div>
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>

        @if (!FilteredResources.Any())
        {
            <div class="empty-state">
                <div class="empty-state-icon"><i class="icon-calendar-days"></i></div>
                <p>No resources found matching your criteria.</p>
            </div>
        }
    </div>
</div>

@if (showModal)
{
    <div class="modal-backdrop" @onclick="CloseModal">
        <div class="modal modal-lg" @onclick:stopPropagation="true" role="dialog" aria-labelledby="modal-title-allocation">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title-allocation">@(isEditing ? "Edit Allocation" : "Add Allocation")</h3>
                <button class="modal-close" @onclick="CloseModal">&times;</button>
            </div>
            <div class="modal-body">
                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <div class="alert alert-danger">@errorMessage</div>
                }
                @if (!string.IsNullOrEmpty(successMessage))
                {
                    <div class="alert alert-success">@successMessage</div>
                }
                @if (overlapWarningMessage != null)
                {
                    <div class="alert alert-warning">@overlapWarningMessage</div>
                }

                <div class="form-group">
                    <label class="form-label">Resource *</label>
                    <select class="form-control" @bind="modalResourceId" @bind:after="OnResourceChanged" disabled="@isEditing">
                        <option value="0">Select a resource...</option>
                        @foreach (var resource in resources.Where(r => !r.EndDate.HasValue || r.EndDate.Value >= DateTime.Today))
                        {
                            <option value="@resource.Id">@resource.Name (@string.Join(", ", resource.ResourceRoles.Select(rr => rr.Role.Name)))</option>
                        }
                    </select>
                </div>

                @if (modalResourceId > 0)
                {
                    var selectedResource = resources.FirstOrDefault(r => r.Id == modalResourceId);

                    <div class="form-group">
                        <label class="form-label">Project *</label>
                        <select class="form-control" @bind="modalProjectId">
                            <option value="0">Select a project...</option>
                            @foreach (var project in projects)
                            {
                                <option value="@project.Id">@project.Name</option>
                            }
                        </select>
                    </div>

                    <div class="form-row">
                        <div class="form-group form-group-half">
                            <label class="form-label">Start Date *</label>
                            <input type="date" class="form-control" @bind="modalStartDate" />
                        </div>
                        <div class="form-group form-group-half">
                            <label class="form-label">End Date *</label>
                            <input type="date" class="form-control" @bind="modalEndDate" max="@(selectedResource?.EndDate?.ToString("yyyy-MM-dd"))" />
                            @if (selectedResource?.EndDate.HasValue == true)
                            {
                                <small class="form-hint">Resource contract ends: @selectedResource.EndDate.Value.ToString("MMM dd, yyyy")</small>
                            }
                        </div>
                    </div>

                    @if (showPercentageField)
                    {
                        <div class="form-group">
                            <label class="form-label">Allocation Percentage * (1-100)</label>
                            <input type="number" class="form-control" min="1" max="100" @bind="modalPercentage" />
                        </div>
                    }
                }
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CloseModal">Cancel</button>
                <button class="btn btn-primary" @onclick="SaveAllocation">@(isEditing ? "Save" : "Create Allocation")</button>
            </div>
        </div>
    </div>
}

<ConfirmDeleteModal Visible="showDeleteConfirm"
    Message="@($"Are you sure you want to delete the allocation for \"{allocationToDelete?.Resource?.Name}\" on \"{allocationToDelete?.Project?.Name}\"?")"
    OnConfirm="DeleteAllocation"
    OnCancel="CancelDelete" />

@code {
    private List<Allocation> allocations = new();
    private List<Resource> resources = new();
    private List<Project> projects = new();
    private List<Role> roles = new();
    private bool showDeleteConfirm = false;
    private Allocation? allocationToDelete = null;

    private string searchTerm = "";
    private int selectedRoleId = 0;
    private DateTime? filterStartDate;
    private DateTime? filterEndDate;
    private HashSet<int> expandedResources = new();

    private bool showModal = false;
    private bool isEditing = false;
    private Allocation? currentAllocation;
    private string errorMessage = "";
    private string successMessage = "";
    private string? overlapWarningMessage;

    private int modalResourceId = 0;
    private int modalProjectId = 0;
    private DateTime modalStartDate = DateTime.Today;
    private DateTime modalEndDate = DateTime.Today.AddMonths(1);
    private int? modalPercentage;
    private bool showPercentageField = false;

    // Sorting
    private string sortColumn = "Resource";
    private bool sortAscending = true;

    private IEnumerable<Resource> FilteredResources
    {
        get
        {
            var filtered = resources.AsEnumerable();

            if (!string.IsNullOrWhiteSpace(searchTerm))
                filtered = filtered.Where(r => r.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));

            if (selectedRoleId > 0)
                filtered = filtered.Where(r => r.ResourceRoles.Any(rr => rr.RoleId == selectedRoleId));

            // If date range is specified, only show resources with allocations in that range
            if (filterStartDate.HasValue && filterEndDate.HasValue)
            {
                filtered = filtered.Where(r => allocations.Any(a =>
                    a.ResourceId == r.Id &&
                    a.StartDate <= filterEndDate.Value &&
                    a.EndDate >= filterStartDate.Value));
            }

            return filtered;
        }
    }

    private IEnumerable<Resource> SortedResources
    {
        get
        {
            var data = FilteredResources;
            return sortColumn switch
            {
                "Resource" => sortAscending ? data.OrderBy(r => r.Name) : data.OrderByDescending(r => r.Name),
                "Role" => sortAscending ? data.OrderBy(r => r.ResourceRoles.FirstOrDefault()?.Role.Name ?? "zzz") : data.OrderByDescending(r => r.ResourceRoles.FirstOrDefault()?.Role.Name ?? ""),
                _ => data.OrderBy(r => r.Name)
            };
        }
    }

    private IEnumerable<Allocation> GetResourceAllocations(int resourceId)
    {
        var filtered = allocations.Where(a => a.ResourceId == resourceId);

        if (filterStartDate.HasValue && filterEndDate.HasValue)
        {
            filtered = filtered.Where(a =>
                a.StartDate <= filterEndDate.Value &&
                a.EndDate >= filterStartDate.Value);
        }

        return filtered;
    }

    private int GetMaxOverlapAllocation(int resourceId)
    {
        var resourceAllocations = GetResourceAllocations(resourceId)
            .Where(a => a.Percentage.HasValue)
            .ToList();

        if (!resourceAllocations.Any()) return 0;

        // Find all date boundaries
        var boundaries = new HashSet<DateTime>();
        foreach (var alloc in resourceAllocations)
        {
            boundaries.Add(alloc.StartDate);
            boundaries.Add(alloc.EndDate);
        }

        var sortedBoundaries = boundaries.OrderBy(d => d).ToList();
        int maxTotal = 0;

        // Calculate total allocation at each period between boundaries
        for (int i = 0; i < sortedBoundaries.Count - 1; i++)
        {
            var periodStart = sortedBoundaries[i];
            var periodEnd = sortedBoundaries[i + 1];
            var midPoint = periodStart.AddDays((periodEnd - periodStart).TotalDays / 2);

            var periodTotal = resourceAllocations
                .Where(a => a.StartDate <= midPoint && a.EndDate >= midPoint)
                .Sum(a => a.Percentage ?? 0);

            if (periodTotal > maxTotal)
                maxTotal = periodTotal;
        }

        return maxTotal;
    }

    private bool HasOverlappingDates(int resourceId)
    {
        var resourceAllocations = GetResourceAllocations(resourceId).ToList();

        for (int i = 0; i < resourceAllocations.Count; i++)
        {
            for (int j = i + 1; j < resourceAllocations.Count; j++)
            {
                var a1 = resourceAllocations[i];
                var a2 = resourceAllocations[j];

                // Check if date ranges overlap
                if (a1.StartDate <= a2.EndDate && a1.EndDate >= a2.StartDate)
                    return true;
            }
        }

        return false;
    }

    private int GetOverlappingAllocationsCount(Allocation allocation)
    {
        return allocations.Count(a =>
            a.Id != allocation.Id &&
            a.ResourceId == allocation.ResourceId &&
            a.StartDate <= allocation.EndDate &&
            a.EndDate >= allocation.StartDate);
    }

    private string GetAllocationClass(int total) => total > 100 ? "danger" : total >= 80 ? "warning" : "normal";

    private void SetSort(string column)
    {
        if (sortColumn == column)
            sortAscending = !sortAscending;
        else
        {
            sortColumn = column;
            sortAscending = true;
        }
    }

    private string GetSortClass(string column) => sortColumn == column ? (sortAscending ? "asc" : "desc") : "";

    private void OnFilterChanged() { }

    protected override async Task OnInitializedAsync()
    {
        resources = await DbContext.Resources.Include(r => r.ResourceRoles).ThenInclude(rr => rr.Role).OrderBy(r => r.Name).ToListAsync();
        projects = await DbContext.Projects.OrderBy(p => p.Name).ToListAsync();
        roles = await DbContext.Roles.OrderBy(r => r.Name).ToListAsync();
        await LoadAllocations();
    }

    private async Task LoadAllocations()
    {
        allocations = await DbContext.Allocations
            .Include(a => a.Resource).ThenInclude(r => r.ResourceRoles).ThenInclude(rr => rr.Role)
            .Include(a => a.Project)
            .ToListAsync();
    }

    private void ToggleResource(int resourceId)
    {
        if (expandedResources.Contains(resourceId))
            expandedResources.Remove(resourceId);
        else
            expandedResources.Add(resourceId);
    }

    private bool allExpanded = false;

    private void ToggleExpandAll()
    {
        if (allExpanded)
        {
            expandedResources.Clear();
        }
        else
        {
            foreach (var resource in SortedResources.Where(r => GetResourceAllocations(r.Id).Any()))
            {
                expandedResources.Add(resource.Id);
            }
        }
        allExpanded = !allExpanded;
    }

    private void OpenAddModal()
    {
        currentAllocation = null;
        modalResourceId = 0;
        modalProjectId = 0;
        modalStartDate = DateTime.Today;
        modalEndDate = DateTime.Today.AddMonths(1);
        modalPercentage = null;
        showPercentageField = false;
        errorMessage = "";
        successMessage = "";
        overlapWarningMessage = null;
        isEditing = false;
        showModal = true;
    }

    private void OpenAddModalForResource(Resource resource)
    {
        currentAllocation = null;
        modalResourceId = resource.Id;
        modalProjectId = 0;
        modalStartDate = DateTime.Today;
        modalEndDate = DateTime.Today.AddMonths(1);
        modalPercentage = null;
        showPercentageField = resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity);
        errorMessage = "";
        successMessage = "";
        overlapWarningMessage = null;
        isEditing = false;
        showModal = true;
    }

    private void OpenEditModal(Allocation allocation)
    {
        currentAllocation = allocation;
        modalResourceId = allocation.ResourceId;
        modalProjectId = allocation.ProjectId;
        modalStartDate = allocation.StartDate;
        modalEndDate = allocation.EndDate;
        modalPercentage = allocation.Percentage;
        showPercentageField = allocation.Resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity);
        errorMessage = "";
        successMessage = "";
        overlapWarningMessage = null;
        isEditing = true;
        showModal = true;
    }

    private void CloseModal()
    {
        showModal = false;
        errorMessage = "";
        successMessage = "";
        overlapWarningMessage = null;
    }

    private void OnResourceChanged()
    {
        var resource = resources.FirstOrDefault(r => r.Id == modalResourceId);
        if (resource != null)
        {
            showPercentageField = resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity);
            if (!showPercentageField) modalPercentage = null;
        }
    }

    private async Task SaveAllocation()
    {
        errorMessage = "";
        successMessage = "";
        overlapWarningMessage = null;

        if (modalResourceId == 0)
        {
            errorMessage = "Please select a resource.";
            return;
        }

        if (modalProjectId == 0)
        {
            errorMessage = "Please select a project.";
            return;
        }

        if (modalEndDate < modalStartDate)
        {
            errorMessage = "End date must be after start date.";
            return;
        }

        var resource = resources.First(r => r.Id == modalResourceId);
        var requiresCapacity = resource.ResourceRoles.Any(rr => rr.Role.RequiresCapacity);

        if (requiresCapacity && (!modalPercentage.HasValue || modalPercentage < 1 || modalPercentage > 100))
        {
            errorMessage = "Please enter a valid percentage between 1 and 100.";
            return;
        }

        // Check if resource has end date and allocation extends beyond it
        if (resource.EndDate.HasValue && modalEndDate > resource.EndDate.Value)
        {
            errorMessage = $"Allocation end date cannot exceed resource contract end date ({resource.EndDate.Value:MMM dd, yyyy}).";
            return;
        }

        if (isEditing && currentAllocation != null)
        {
            var result = await AllocationService.UpdateAllocationAsync(
                currentAllocation.Id,
                modalStartDate,
                modalEndDate,
                requiresCapacity ? modalPercentage : null);

            if (!result.Success)
            {
                errorMessage = result.ErrorMessage ?? "Failed to update allocation.";
                return;
            }

            if (result.OverlappingPeriods?.Any() == true)
            {
                overlapWarningMessage = $"Warning: This allocation overlaps with {result.OverlappingPeriods.Count} other allocation(s).";
            }

            await LoadAllocations();
            CloseModal();
        }
        else
        {
            // Check for duplicate allocation (same resource + project with overlapping dates)
            var existingAllocation = allocations.FirstOrDefault(a =>
                a.ResourceId == modalResourceId &&
                a.ProjectId == modalProjectId &&
                a.StartDate <= modalEndDate &&
                a.EndDate >= modalStartDate);

            if (existingAllocation != null)
            {
                errorMessage = $"An allocation already exists for this resource and project that overlaps with the selected dates ({existingAllocation.StartDate:MMM dd} - {existingAllocation.EndDate:MMM dd}).";
                return;
            }

            var result = await AllocationService.CreateAllocationAsync(
                modalResourceId,
                modalProjectId,
                modalStartDate,
                modalEndDate,
                requiresCapacity ? modalPercentage : null);

            if (!result.Success)
            {
                errorMessage = result.ErrorMessage ?? "Failed to create allocation.";
                return;
            }

            if (result.OverlappingPeriods?.Any() == true)
            {
                overlapWarningMessage = $"Allocation created. Note: This overlaps with {result.OverlappingPeriods.Count} other allocation(s).";
            }

            await LoadAllocations();
            expandedResources.Add(modalResourceId);
            successMessage = "Allocation created successfully.";

            // Reset for another allocation
            modalProjectId = 0;
            modalStartDate = DateTime.Today;
            modalEndDate = DateTime.Today.AddMonths(1);
        }
    }

    private void ConfirmDelete(Allocation allocation)
    {
        allocationToDelete = allocation;
        showDeleteConfirm = true;
    }

    private void CancelDelete()
    {
        allocationToDelete = null;
        showDeleteConfirm = false;
    }

    private async Task DeleteAllocation()
    {
        if (allocationToDelete == null) return;
        await AllocationService.DeleteAllocationAsync(allocationToDelete.Id);
        allocationToDelete = null;
        showDeleteConfirm = false;
        await LoadAllocations();
    }
}
