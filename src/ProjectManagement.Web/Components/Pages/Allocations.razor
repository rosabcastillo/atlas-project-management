@page "/allocations"
@using Microsoft.EntityFrameworkCore
@using ProjectManagement.Infrastructure.Data
@using ProjectManagement.Domain.Entities
@using ProjectManagement.Application.Services
@inject AppDbContext DbContext
@inject AllocationService AllocationService
@rendermode InteractiveServer

<PageTitle>Allocations - Project Management</PageTitle>

<div class="page-header">
    <div>
        <h1 class="page-title">Allocations</h1>
        <p class="page-subtitle">Manage resource allocations across projects</p>
    </div>
    <button class="btn btn-primary" @onclick="OpenAddModal">+ Add Allocation</button>
</div>

<div class="glass-card">
    <div class="action-bar">
        <div class="action-bar-left">
            <div class="search-box">
                <input type="text" class="form-control" placeholder="Search resources..." @bind="searchTerm" @bind:event="oninput" />
            </div>
            <select class="form-control" style="width: auto; min-width: 200px;" @bind="selectedPeriodId" @bind:after="OnFilterChanged">
                <option value="0">All Periods</option>
                @foreach (var period in periods)
                {
                    <option value="@period.Id">@period.Name</option>
                }
            </select>
            <select class="form-control" style="width: auto;" @bind="selectedRoleId" @bind:after="OnFilterChanged">
                <option value="0">All Roles</option>
                @foreach (var role in roles)
                {
                    <option value="@role.Id">@role.Name</option>
                }
            </select>
        </div>
        <div class="action-bar-right">
            <button class="btn btn-secondary btn-sm" @onclick="ExpandAll">Expand All</button>
            <button class="btn btn-secondary btn-sm" @onclick="CollapseAll">Collapse All</button>
        </div>
    </div>

    <div class="table-container">
        <table>
            <thead>
                <tr>
                    <th class="sortable @(GetSortClass("Resource"))" @onclick='() => SetSort("Resource")'>Resource</th>
                    <th class="sortable @(GetSortClass("Role"))" @onclick='() => SetSort("Role")'>Role</th>
                    <th>Total Allocation</th>
                    <th>Projects</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var resource in SortedResources)
                {
                    var resourceAllocations = GetResourceAllocations(resource.Id);
                    var hasAllocations = resourceAllocations.Any();
                    var isExpanded = expandedResources.Contains(resource.Id);

                    <tr class="@(hasAllocations ? "resource-expandable" : "")">
                        <td>
                            @if (hasAllocations)
                            {
                                <button class="expand-btn" @onclick="() => ToggleResource(resource.Id)">
                                    @(isExpanded ? "‚ñº" : "‚ñ∂")
                                </button>
                            }
                            else
                            {
                                <span class="expand-placeholder"></span>
                            }
                            <strong>@resource.Name</strong>
                        </td>
                        <td>
                            <span class="badge @(resource.Role.RequiresCapacity ? "badge-primary" : "badge-secondary")">
                                @resource.Role.Name
                            </span>
                        </td>
                        <td>
                            @if (resource.Role.RequiresCapacity)
                            {
                                var maxPeriodAllocation = GetMaxPeriodAllocation(resource.Id);
                                var hasOverlap = HasOverlappingPeriodsForResource(resource.Id);
                                <div class="allocation-bar-container">
                                    <div class="allocation-bar">
                                        <div class="allocation-bar-fill @GetAllocationClass(maxPeriodAllocation)"
                                             style="width: @Math.Min(maxPeriodAllocation, 100)%"></div>
                                    </div>
                                    <span class="allocation-text @(maxPeriodAllocation > 100 ? "danger" : "")">
                                        @maxPeriodAllocation%
                                        @if (hasOverlap)
                                        {
                                            <span class="overlap-indicator" title="Has overlapping periods">‚ö†Ô∏è</span>
                                        }
                                    </span>
                                </div>
                            }
                            else
                            {
                                <span class="badge badge-secondary">N/A</span>
                            }
                        </td>
                        <td>
                            <span class="project-count">@resourceAllocations.Count() project(s)</span>
                        </td>
                        <td>
                            <button class="btn btn-primary btn-sm" @onclick="() => OpenAddModalForResource(resource)">+ Allocate</button>
                        </td>
                    </tr>
                    @if (isExpanded && hasAllocations)
                    {
                        <tr class="allocation-panel-row">
                            <td colspan="5">
                                <div class="allocation-panel">
                                    @if (resource.Role.RequiresCapacity)
                                    {
                                        @* Show hierarchical period view with cascading allocations for Developer/QA *@
                                        var parentPeriodAllocations = resourceAllocations
                                            .Where(a => IsParentPeriod(a.Period))
                                            .GroupBy(a => a.Period)
                                            .OrderBy(g => g.Key.StartDate)
                                            .ToList();

                                        var childPeriods = GetChildPeriodsForResource(resourceAllocations);

                                        @* Show parent period (quarterly) allocations first as base *@
                                        @foreach (var parentGroup in parentPeriodAllocations)
                                        {
                                            var parentTotal = parentGroup.Sum(a => a.Percentage ?? 0);
                                            <div class="period-group parent-period">
                                                <div class="period-header parent-header">
                                                    <span class="period-name">
                                                        <span class="period-type-badge">BASE</span>
                                                        @parentGroup.Key.Name
                                                    </span>
                                                    <div class="period-total">
                                                        <span class="allocation-text-sm">@parentTotal% base</span>
                                                    </div>
                                                </div>
                                                <div class="allocation-list">
                                                    @foreach (var allocation in parentGroup.OrderBy(a => a.Project.Name))
                                                    {
                                                        <div class="allocation-item">
                                                            <div class="allocation-item-info">
                                                                <span class="allocation-project">@allocation.Project.Name</span>
                                                            </div>
                                                            <div class="allocation-item-actions">
                                                                <span class="allocation-percentage-badge">@(allocation.Percentage ?? 0)%</span>
                                                                <button class="btn btn-secondary btn-xs" @onclick="() => OpenEditModal(allocation)">Edit</button>
                                                                <button class="btn btn-danger btn-xs" @onclick="() => DeleteAllocation(allocation)">Delete</button>
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        }

                                        @* Show child periods (months) with effective totals *@
                                        @foreach (var childPeriod in childPeriods.OrderBy(p => p.StartDate))
                                        {
                                            var directAllocations = resourceAllocations
                                                .Where(a => a.PeriodId == childPeriod.Id)
                                                .ToList();

                                            var inheritedAllocations = GetInheritedAllocations(resourceAllocations, childPeriod);
                                            var directTotal = directAllocations.Sum(a => a.Percentage ?? 0);
                                            var inheritedTotal = inheritedAllocations.Sum(a => a.Percentage ?? 0);
                                            var effectiveTotal = directTotal + inheritedTotal;
                                            var hasInherited = inheritedAllocations.Any();

                                            <div class="period-group child-period-group">
                                                <div class="period-header">
                                                    <span class="period-name">
                                                        @childPeriod.Name
                                                        @if (hasInherited)
                                                        {
                                                            <span class="inherited-indicator" title="Includes inherited allocations from parent period">+inherited</span>
                                                        }
                                                    </span>
                                                    <div class="period-total">
                                                        <div class="allocation-bar-mini">
                                                            <div class="allocation-bar-fill @GetAllocationClass(effectiveTotal)"
                                                                 style="width: @Math.Min(effectiveTotal, 100)%"></div>
                                                        </div>
                                                        <span class="allocation-text-sm @(effectiveTotal > 100 ? "danger" : "")">
                                                            @effectiveTotal%
                                                            @if (effectiveTotal > 100)
                                                            {
                                                                <span>‚ö†Ô∏è</span>
                                                            }
                                                        </span>
                                                    </div>
                                                </div>
                                                <div class="allocation-list">
                                                    @* Show inherited allocations first *@
                                                    @foreach (var allocation in inheritedAllocations.OrderBy(a => a.Project.Name))
                                                    {
                                                        <div class="allocation-item inherited-item">
                                                            <div class="allocation-item-info">
                                                                <span class="inherited-marker">‚Ü≥</span>
                                                                <span class="allocation-project inherited">@allocation.Project.Name</span>
                                                                <span class="inherited-from">from @allocation.Period.Name</span>
                                                            </div>
                                                            <div class="allocation-item-actions">
                                                                <span class="allocation-percentage-badge inherited">@(allocation.Percentage ?? 0)%</span>
                                                            </div>
                                                        </div>
                                                    }
                                                    @* Show direct allocations *@
                                                    @foreach (var allocation in directAllocations.OrderBy(a => a.Project.Name))
                                                    {
                                                        <div class="allocation-item">
                                                            <div class="allocation-item-info">
                                                                <span class="allocation-project">@allocation.Project.Name</span>
                                                            </div>
                                                            <div class="allocation-item-actions">
                                                                <span class="allocation-percentage-badge">@(allocation.Percentage ?? 0)%</span>
                                                                <button class="btn btn-secondary btn-xs" @onclick="() => OpenEditModal(allocation)">Edit</button>
                                                                <button class="btn btn-danger btn-xs" @onclick="() => DeleteAllocation(allocation)">Delete</button>
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        }

                                        @* Show periods without parent (standalone months/quarters with no overlap) *@
                                        var standalonePeriods = resourceAllocations
                                            .Where(a => !IsParentPeriod(a.Period) && !childPeriods.Any(cp => cp.Id == a.PeriodId))
                                            .GroupBy(a => a.Period)
                                            .OrderBy(g => g.Key.StartDate);

                                        foreach (var periodGroup in standalonePeriods)
                                        {
                                            var periodTotal = periodGroup.Sum(a => a.Percentage ?? 0);

                                            <div class="period-group">
                                                <div class="period-header">
                                                    <span class="period-name">@periodGroup.Key.Name</span>
                                                    <div class="period-total">
                                                        <div class="allocation-bar-mini">
                                                            <div class="allocation-bar-fill @GetAllocationClass(periodTotal)"
                                                                 style="width: @Math.Min(periodTotal, 100)%"></div>
                                                        </div>
                                                        <span class="allocation-text-sm @(periodTotal > 100 ? "danger" : "")">@periodTotal%</span>
                                                    </div>
                                                </div>
                                                <div class="allocation-list">
                                                    @foreach (var allocation in periodGroup.OrderBy(a => a.Project.Name))
                                                    {
                                                        <div class="allocation-item">
                                                            <div class="allocation-item-info">
                                                                <span class="allocation-project">@allocation.Project.Name</span>
                                                            </div>
                                                            <div class="allocation-item-actions">
                                                                <span class="allocation-percentage-badge">@(allocation.Percentage ?? 0)%</span>
                                                                <button class="btn btn-secondary btn-xs" @onclick="() => OpenEditModal(allocation)">Edit</button>
                                                                <button class="btn btn-danger btn-xs" @onclick="() => DeleteAllocation(allocation)">Delete</button>
                                                            </div>
                                                        </div>
                                                    }
                                                </div>
                                            </div>
                                        }
                                    }
                                    else
                                    {
                                        @* Simple flat list for PO/SM/BA - no period grouping, no capacity *@
                                        <div class="allocation-list">
                                            @foreach (var allocation in resourceAllocations.OrderBy(a => a.Project.Name).ThenBy(a => a.Period.StartDate))
                                            {
                                                <div class="allocation-item">
                                                    <div class="allocation-item-info">
                                                        <span class="allocation-project">@allocation.Project.Name</span>
                                                        <span class="allocation-period">@allocation.Period.Name</span>
                                                    </div>
                                                    <div class="allocation-item-actions">
                                                        <button class="btn btn-secondary btn-xs" @onclick="() => OpenEditModal(allocation)">Edit</button>
                                                        <button class="btn btn-danger btn-xs" @onclick="() => DeleteAllocation(allocation)">Delete</button>
                                                    </div>
                                                </div>
                                            }
                                        </div>
                                    }
                                </div>
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>

        @if (!FilteredResources.Any())
        {
            <div class="empty-state">
                <div class="empty-state-icon">üìÖ</div>
                <p>No resources found matching your criteria.</p>
            </div>
        }
    </div>
</div>

@if (showModal)
{
    <div class="modal-backdrop" @onclick="CloseModal">
        <div class="modal modal-lg" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3 class="modal-title">@(isEditing ? "Edit Allocation" : "Add Allocations")</h3>
                <button class="modal-close" @onclick="CloseModal">&times;</button>
            </div>
            <div class="modal-body">
                @if (!string.IsNullOrEmpty(errorMessage))
                {
                    <div class="alert alert-danger">@errorMessage</div>
                }
                @if (!string.IsNullOrEmpty(successMessage))
                {
                    <div class="alert alert-success">@successMessage</div>
                }

                <div class="form-group">
                    <label class="form-label">Resource *</label>
                    <select class="form-control" @bind="modalResourceId" @bind:after="OnResourceChanged" disabled="@isEditing">
                        <option value="0">Select a resource...</option>
                        @foreach (var resource in resources)
                        {
                            <option value="@resource.Id">@resource.Name (@resource.Role.Name)</option>
                        }
                    </select>
                </div>

                @if (modalResourceId > 0)
                {
                    var selectedResource = resources.FirstOrDefault(r => r.Id == modalResourceId);

                    @if (showPercentageField)
                    {
                        <div class="form-group">
                            <label class="form-label">Allocation Percentage * (1-100)</label>
                            <input type="number" class="form-control" min="1" max="100" @bind="modalPercentage" />
                            <small class="form-hint">This percentage will be applied to each project/period combination</small>
                        </div>
                    }

                    @if (isEditing)
                    {
                        @* Single select for edit mode *@
                        <div class="form-group">
                            <label class="form-label">Project *</label>
                            <select class="form-control" @bind="modalProjectId">
                                <option value="0">Select a project...</option>
                                @foreach (var project in projects)
                                {
                                    <option value="@project.Id">@project.Name</option>
                                }
                            </select>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Period *</label>
                            <select class="form-control" @bind="modalPeriodId">
                                <option value="0">Select a period...</option>
                                @foreach (var period in periods)
                                {
                                    <option value="@period.Id">@period.Name</option>
                                }
                            </select>
                        </div>
                    }
                    else
                    {
                        @* Multi-select for add mode *@
                        <div class="form-row">
                            <div class="form-group form-group-half">
                                <label class="form-label">Projects * <span class="selection-count">(@selectedProjectIds.Count selected)</span></label>
                                <div class="checkbox-list">
                                    @foreach (var project in projects)
                                    {
                                        <label class="checkbox-item">
                                            <input type="checkbox" checked="@selectedProjectIds.Contains(project.Id)"
                                                   @onchange="() => ToggleProjectSelection(project.Id)" />
                                            <span>@project.Name</span>
                                        </label>
                                    }
                                </div>
                            </div>

                            <div class="form-group form-group-half">
                                <label class="form-label">Periods * <span class="selection-count">(@selectedPeriodIds.Count selected)</span></label>
                                <div class="checkbox-list">
                                    @foreach (var period in periods.OrderBy(p => p.StartDate))
                                    {
                                        <label class="checkbox-item">
                                            <input type="checkbox" checked="@selectedPeriodIds.Contains(period.Id)"
                                                   @onchange="() => TogglePeriodSelection(period.Id)" />
                                            <span>@period.Name</span>
                                        </label>
                                    }
                                </div>
                            </div>
                        </div>

                        @if (selectedProjectIds.Any() && selectedPeriodIds.Any())
                        {
                            <div class="allocation-preview">
                                <label class="form-label">Preview: @(selectedProjectIds.Count * selectedPeriodIds.Count) allocation(s) will be created</label>
                            </div>
                        }
                    }
                }
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CloseModal">Cancel</button>
                <button class="btn btn-primary" @onclick="SaveAllocation">@(isEditing ? "Save" : "Create Allocations")</button>
            </div>
        </div>
    </div>
}

@if (showOverlapConfirmation)
{
    <div class="modal-backdrop" @onclick="CancelOverlapConfirmation">
        <div class="modal" @onclick:stopPropagation="true">
            <div class="modal-header">
                <h3 class="modal-title">‚ö†Ô∏è Overlapping Period Warning</h3>
                <button class="modal-close" @onclick="CancelOverlapConfirmation">&times;</button>
            </div>
            <div class="modal-body">
                <p>The following allocations have overlapping periods:</p>
                <div class="overlap-warning-list">
                    @foreach (var warning in overlapWarnings)
                    {
                        <div class="overlap-warning-item">
                            <strong>@warning.ProjectName</strong>
                            @if (warning.IsNewPeriodLarger)
                            {
                                <p>
                                    You are adding an allocation for <strong>@warning.NewPeriodName</strong> which contains
                                    an existing allocation for <strong>@warning.ExistingPeriodName</strong>.
                                </p>
                                <p class="warning-note">
                                    The resource will have allocations in both periods. The larger period (@warning.NewPeriodName)
                                    will cascade to the child period, potentially causing over-allocation.
                                </p>
                            }
                            else
                            {
                                <p>
                                    You are adding an allocation for <strong>@warning.NewPeriodName</strong> which is within
                                    an existing allocation for <strong>@warning.ExistingPeriodName</strong>.
                                </p>
                                <p class="warning-note">
                                    The resource already has a base allocation in @warning.ExistingPeriodName that cascades to this period.
                                </p>
                            }
                        </div>
                    }
                </div>
                <p class="confirmation-question">Do you want to proceed with creating these allocations?</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @onclick="CancelOverlapConfirmation">Cancel</button>
                <button class="btn btn-warning" @onclick="ConfirmOverlapAndSave">Proceed Anyway</button>
            </div>
        </div>
    </div>
}

@code {
    private List<Allocation> allocations = new();
    private List<Resource> resources = new();
    private List<Project> projects = new();
    private List<Period> periods = new();
    private List<Role> roles = new();

    private string searchTerm = "";
    private int selectedPeriodId = 0;
    private int selectedRoleId = 0;
    private HashSet<int> expandedResources = new();

    private bool showModal = false;
    private bool isEditing = false;
    private Allocation? currentAllocation;
    private string errorMessage = "";

    private int modalResourceId = 0;
    private int modalProjectId = 0;
    private int modalPeriodId = 0;
    private int? modalPercentage;
    private bool showPercentageField = false;

    // Multi-select for Add mode
    private HashSet<int> selectedProjectIds = new();
    private HashSet<int> selectedPeriodIds = new();
    private string successMessage = "";

    // Overlap confirmation
    private bool showOverlapConfirmation = false;
    private List<OverlapWarning> overlapWarnings = new();
    private class OverlapWarning
    {
        public int ProjectId { get; set; }
        public string ProjectName { get; set; } = "";
        public int NewPeriodId { get; set; }
        public string NewPeriodName { get; set; } = "";
        public int ExistingPeriodId { get; set; }
        public string ExistingPeriodName { get; set; } = "";
        public bool IsNewPeriodLarger { get; set; }
    }

    // Sorting
    private string sortColumn = "Resource";
    private bool sortAscending = true;

    private IEnumerable<Resource> FilteredResources
    {
        get
        {
            var filtered = resources.AsEnumerable();

            if (!string.IsNullOrWhiteSpace(searchTerm))
                filtered = filtered.Where(r => r.Name.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));

            if (selectedRoleId > 0)
                filtered = filtered.Where(r => r.RoleId == selectedRoleId);

            // If period is selected, only show resources with allocations in that period
            if (selectedPeriodId > 0)
                filtered = filtered.Where(r => allocations.Any(a => a.ResourceId == r.Id && a.PeriodId == selectedPeriodId));

            return filtered;
        }
    }

    private IEnumerable<Resource> SortedResources
    {
        get
        {
            var data = FilteredResources;
            return sortColumn switch
            {
                "Resource" => sortAscending ? data.OrderBy(r => r.Name) : data.OrderByDescending(r => r.Name),
                "Role" => sortAscending ? data.OrderBy(r => r.Role.Name) : data.OrderByDescending(r => r.Role.Name),
                _ => data.OrderBy(r => r.Name)
            };
        }
    }

    private IEnumerable<Allocation> GetResourceAllocations(int resourceId)
    {
        var filtered = allocations.Where(a => a.ResourceId == resourceId);
        if (selectedPeriodId > 0)
            filtered = filtered.Where(a => a.PeriodId == selectedPeriodId);
        return filtered;
    }

    private int GetTotalAllocation(int resourceId)
    {
        var resourceAllocations = GetResourceAllocations(resourceId);
        return resourceAllocations.Where(a => a.Percentage.HasValue).Sum(a => a.Percentage ?? 0);
    }

    private int GetMaxPeriodAllocation(int resourceId)
    {
        var resourceAllocations = GetResourceAllocations(resourceId);
        var periodTotals = resourceAllocations
            .GroupBy(a => a.PeriodId)
            .Select(g => g.Where(a => a.Percentage.HasValue).Sum(a => a.Percentage ?? 0));

        return periodTotals.Any() ? periodTotals.Max() : 0;
    }

    private bool HasOverlappingPeriodsForResource(int resourceId)
    {
        var resourceAllocations = GetResourceAllocations(resourceId);
        return HasOverlappingPeriods(resourceAllocations);
    }

    private int GetTotalAllocationExcluding(int resourceId, int periodId, int? excludeAllocationId)
    {
        var query = allocations.Where(a => a.ResourceId == resourceId && a.PeriodId == periodId && a.Percentage.HasValue);
        if (excludeAllocationId.HasValue) query = query.Where(a => a.Id != excludeAllocationId.Value);
        return query.Sum(a => a.Percentage ?? 0);
    }

    private string GetAllocationClass(int total) => total > 100 ? "danger" : total >= 80 ? "warning" : "normal";

    private bool HasOverlappingPeriods(IEnumerable<Allocation> resourceAllocations)
    {
        var allocatedPeriods = resourceAllocations.Select(a => a.Period).Distinct().ToList();

        foreach (var period1 in allocatedPeriods)
        {
            foreach (var period2 in allocatedPeriods)
            {
                if (period1.Id != period2.Id && PeriodsOverlap(period1, period2))
                {
                    return true;
                }
            }
        }
        return false;
    }

    private bool PeriodsOverlap(Period p1, Period p2)
    {
        // Check if one period contains another or they overlap
        return (p1.StartDate <= p2.StartDate && p1.EndDate >= p2.EndDate) ||
               (p2.StartDate <= p1.StartDate && p2.EndDate >= p1.EndDate) ||
               (p1.StartDate <= p2.EndDate && p1.EndDate >= p2.StartDate);
    }

    private bool IsChildPeriod(Period period)
    {
        // A period is a "child" if it's a Month type or if there's a longer period that contains it
        if (period.Type == ProjectManagement.Domain.Enums.PeriodType.Month)
        {
            return periods.Any(p => p.Id != period.Id &&
                                    p.StartDate <= period.StartDate &&
                                    p.EndDate >= period.EndDate);
        }
        return false;
    }

    private bool IsParentPeriod(Period period)
    {
        // A period is a "parent" if it contains other periods (e.g., Quarter contains Months)
        return periods.Any(p => p.Id != period.Id &&
                               period.StartDate <= p.StartDate &&
                               period.EndDate >= p.EndDate);
    }

    private List<Period> GetChildPeriodsForResource(IEnumerable<Allocation> resourceAllocations)
    {
        // Get all periods that are children of any parent period the resource is allocated to
        var parentPeriods = resourceAllocations
            .Select(a => a.Period)
            .Where(p => IsParentPeriod(p))
            .Distinct()
            .ToList();

        var childPeriodIds = new HashSet<int>();

        foreach (var parent in parentPeriods)
        {
            // Find all periods that fall within this parent
            var children = periods.Where(p => p.Id != parent.Id &&
                                              parent.StartDate <= p.StartDate &&
                                              parent.EndDate >= p.EndDate);
            foreach (var child in children)
            {
                childPeriodIds.Add(child.Id);
            }
        }

        // Also include any periods the resource is directly allocated to that are children
        foreach (var allocation in resourceAllocations)
        {
            if (IsChildPeriod(allocation.Period))
            {
                childPeriodIds.Add(allocation.PeriodId);
            }
        }

        return periods.Where(p => childPeriodIds.Contains(p.Id)).ToList();
    }

    private List<Allocation> GetInheritedAllocations(IEnumerable<Allocation> resourceAllocations, Period childPeriod)
    {
        // Get allocations from parent periods that apply to this child period
        return resourceAllocations
            .Where(a => a.PeriodId != childPeriod.Id &&
                       a.Period.StartDate <= childPeriod.StartDate &&
                       a.Period.EndDate >= childPeriod.EndDate)
            .ToList();
    }

    private string GetPeriodAllocationSummary(int resourceId, bool requiresCapacity)
    {
        if (!requiresCapacity) return "N/A";

        var resourceAllocs = GetResourceAllocations(resourceId);
        var periodTotals = resourceAllocs
            .GroupBy(a => a.PeriodId)
            .Select(g => g.Where(a => a.Percentage.HasValue).Sum(a => a.Percentage ?? 0))
            .Where(t => t > 0);

        if (!periodTotals.Any()) return "0%";

        var max = periodTotals.Max();
        return $"{max}% max";
    }

    private void SetSort(string column)
    {
        if (sortColumn == column)
            sortAscending = !sortAscending;
        else
        {
            sortColumn = column;
            sortAscending = true;
        }
    }

    private string GetSortClass(string column) => sortColumn == column ? (sortAscending ? "asc" : "desc") : "";

    private async Task OnFilterChanged()
    {
        await Task.CompletedTask;
    }

    protected override async Task OnInitializedAsync()
    {
        resources = await DbContext.Resources.Include(r => r.Role).OrderBy(r => r.Name).ToListAsync();
        projects = await DbContext.Projects.OrderBy(p => p.Name).ToListAsync();
        periods = await DbContext.Periods.OrderBy(p => p.StartDate).ToListAsync();
        roles = await DbContext.Roles.OrderBy(r => r.Name).ToListAsync();
        await LoadAllocations();
    }

    private async Task LoadAllocations()
    {
        allocations = await DbContext.Allocations
            .Include(a => a.Resource).ThenInclude(r => r.Role)
            .Include(a => a.Project)
            .Include(a => a.Period)
            .ToListAsync();
    }

    private void ToggleResource(int resourceId)
    {
        if (expandedResources.Contains(resourceId))
            expandedResources.Remove(resourceId);
        else
            expandedResources.Add(resourceId);
    }

    private void ExpandAll()
    {
        foreach (var resource in SortedResources.Where(r => GetResourceAllocations(r.Id).Any()))
        {
            expandedResources.Add(resource.Id);
        }
    }

    private void CollapseAll()
    {
        expandedResources.Clear();
    }

    private void OpenAddModal()
    {
        currentAllocation = null;
        modalResourceId = 0;
        modalProjectId = 0;
        modalPeriodId = 0;
        modalPercentage = null;
        showPercentageField = false;
        selectedProjectIds.Clear();
        selectedPeriodIds.Clear();
        errorMessage = "";
        successMessage = "";
        isEditing = false;
        showModal = true;
    }

    private void OpenAddModalForResource(Resource resource)
    {
        currentAllocation = null;
        modalResourceId = resource.Id;
        modalProjectId = 0;
        modalPeriodId = 0;
        modalPercentage = null;
        showPercentageField = resource.Role.RequiresCapacity;
        selectedProjectIds.Clear();
        selectedPeriodIds.Clear();
        if (selectedPeriodId > 0)
            selectedPeriodIds.Add(selectedPeriodId);
        errorMessage = "";
        successMessage = "";
        isEditing = false;
        showModal = true;
    }

    private void OpenEditModal(Allocation allocation)
    {
        currentAllocation = allocation;
        modalResourceId = allocation.ResourceId;
        modalProjectId = allocation.ProjectId;
        modalPeriodId = allocation.PeriodId;
        modalPercentage = allocation.Percentage;
        showPercentageField = allocation.Resource.Role.RequiresCapacity;
        selectedProjectIds.Clear();
        selectedPeriodIds.Clear();
        errorMessage = "";
        successMessage = "";
        isEditing = true;
        showModal = true;
    }

    private void CloseModal()
    {
        showModal = false;
        errorMessage = "";
        successMessage = "";
        selectedProjectIds.Clear();
        selectedPeriodIds.Clear();
    }

    private void ToggleProjectSelection(int projectId)
    {
        if (selectedProjectIds.Contains(projectId))
            selectedProjectIds.Remove(projectId);
        else
            selectedProjectIds.Add(projectId);
    }

    private void TogglePeriodSelection(int periodId)
    {
        if (selectedPeriodIds.Contains(periodId))
            selectedPeriodIds.Remove(periodId);
        else
            selectedPeriodIds.Add(periodId);
    }

    private void OnResourceChanged()
    {
        var resource = resources.FirstOrDefault(r => r.Id == modalResourceId);
        if (resource != null)
        {
            showPercentageField = resource.Role.RequiresCapacity;
            if (!showPercentageField) modalPercentage = null;
        }
    }

    private async Task SaveAllocation()
    {
        await SaveAllocationInternal(skipOverlapCheck: false);
    }

    private async Task SaveAllocationInternal(bool skipOverlapCheck)
    {
        errorMessage = "";
        successMessage = "";

        if (modalResourceId == 0)
        {
            errorMessage = "Please select a resource.";
            return;
        }

        var resource = resources.First(r => r.Id == modalResourceId);
        var requiresCapacity = resource.Role.RequiresCapacity;

        if (requiresCapacity && (!modalPercentage.HasValue || modalPercentage < 1 || modalPercentage > 100))
        {
            errorMessage = "Please enter a valid percentage between 1 and 100.";
            return;
        }

        if (isEditing && currentAllocation != null)
        {
            // Edit mode - single allocation
            if (modalProjectId == 0 || modalPeriodId == 0)
            {
                errorMessage = "Please select a project and period.";
                return;
            }

            // Check if resource has end date and period starts after it
            if (resource.EndDate.HasValue)
            {
                var selectedPeriod = periods.First(p => p.Id == modalPeriodId);
                if (selectedPeriod.StartDate > resource.EndDate.Value)
                {
                    errorMessage = $"Cannot allocate {resource.Name} to {selectedPeriod.Name}. Resource contract ends on {resource.EndDate.Value:MMM dd, yyyy}.";
                    return;
                }
            }

            // Check for overlapping periods when editing
            if (!skipOverlapCheck)
            {
                var editOverlaps = CheckForOverlappingAllocations(
                    modalResourceId,
                    new HashSet<int> { modalProjectId },
                    new HashSet<int> { modalPeriodId },
                    currentAllocation.Id);

                if (editOverlaps.Any())
                {
                    overlapWarnings = editOverlaps;
                    showOverlapConfirmation = true;
                    return;
                }
            }

            if (requiresCapacity && modalPercentage.HasValue)
            {
                var currentTotal = GetTotalAllocationExcluding(modalResourceId, modalPeriodId, currentAllocation.Id);
                if (currentTotal + modalPercentage.Value > 100)
                {
                    errorMessage = $"Cannot allocate {modalPercentage}%. Resource already has {currentTotal}% allocated. Maximum available: {100 - currentTotal}%";
                    return;
                }
            }

            var existing = await DbContext.Allocations.FindAsync(currentAllocation.Id);
            if (existing != null)
            {
                existing.ProjectId = modalProjectId;
                existing.PeriodId = modalPeriodId;
                existing.Percentage = requiresCapacity ? modalPercentage : null;
                await DbContext.SaveChangesAsync();
            }

            await LoadAllocations();
            CloseModal();
        }
        else
        {
            // Add mode - multiple allocations
            if (!selectedProjectIds.Any() || !selectedPeriodIds.Any())
            {
                errorMessage = "Please select at least one project and one period.";
                return;
            }

            // Check if resource has end date and any selected period starts after it
            if (resource.EndDate.HasValue)
            {
                var invalidPeriods = periods
                    .Where(p => selectedPeriodIds.Contains(p.Id) && p.StartDate > resource.EndDate.Value)
                    .Select(p => p.Name)
                    .ToList();

                if (invalidPeriods.Any())
                {
                    errorMessage = $"Cannot allocate {resource.Name} to: {string.Join(", ", invalidPeriods)}. Resource contract ends on {resource.EndDate.Value:MMM dd, yyyy}.";
                    return;
                }
            }

            // Check for overlapping periods before creating
            if (!skipOverlapCheck)
            {
                var overlaps = CheckForOverlappingAllocations(modalResourceId, selectedProjectIds, selectedPeriodIds, null);
                if (overlaps.Any())
                {
                    overlapWarnings = overlaps;
                    showOverlapConfirmation = true;
                    return;
                }
            }

            var created = 0;
            var skipped = 0;
            var errors = new List<string>();

            foreach (var projectId in selectedProjectIds)
            {
                foreach (var periodId in selectedPeriodIds)
                {
                    // Check if allocation already exists (same resource + project + period)
                    var existingAllocation = await DbContext.Allocations
                        .FirstOrDefaultAsync(a => a.ResourceId == modalResourceId &&
                                                  a.ProjectId == projectId &&
                                                  a.PeriodId == periodId);

                    if (existingAllocation != null)
                    {
                        skipped++;
                        continue;
                    }

                    // Check capacity for this period if required
                    if (requiresCapacity && modalPercentage.HasValue)
                    {
                        var currentTotal = GetTotalAllocationExcluding(modalResourceId, periodId, null);
                        if (currentTotal + modalPercentage.Value > 100)
                        {
                            var periodName = periods.First(p => p.Id == periodId).Name;
                            errors.Add($"{periodName}: Would exceed 100% ({currentTotal}% + {modalPercentage}%)");
                            continue;
                        }
                    }

                    var newAllocation = new Allocation
                    {
                        ResourceId = modalResourceId,
                        ProjectId = projectId,
                        PeriodId = periodId,
                        Percentage = requiresCapacity ? modalPercentage : null
                    };
                    DbContext.Allocations.Add(newAllocation);
                    created++;
                }
            }

            if (created > 0)
            {
                await DbContext.SaveChangesAsync();
                await LoadAllocations();
            }

            if (errors.Any())
            {
                errorMessage = $"Some allocations skipped due to capacity limits:\n{string.Join("; ", errors)}";
            }

            if (created > 0)
            {
                successMessage = $"Successfully created {created} allocation(s).";
                if (skipped > 0)
                {
                    successMessage += $" {skipped} duplicate(s) skipped.";
                }

                // Keep modal open to show success, clear selections for more
                selectedProjectIds.Clear();
                selectedPeriodIds.Clear();

                // Expand the resource to show new allocations
                expandedResources.Add(modalResourceId);
            }
            else if (skipped > 0)
            {
                errorMessage = $"All {skipped} allocation(s) already exist.";
            }
        }
    }

    private List<OverlapWarning> CheckForOverlappingAllocations(int resourceId, HashSet<int> projectIds, HashSet<int> periodIds, int? excludeAllocationId)
    {
        var warnings = new List<OverlapWarning>();
        var resourceAllocations = allocations.Where(a => a.ResourceId == resourceId);

        if (excludeAllocationId.HasValue)
        {
            resourceAllocations = resourceAllocations.Where(a => a.Id != excludeAllocationId.Value);
        }

        foreach (var projectId in projectIds)
        {
            // Get existing allocations for this resource and project
            var existingForProject = resourceAllocations
                .Where(a => a.ProjectId == projectId)
                .ToList();

            if (!existingForProject.Any()) continue;

            foreach (var newPeriodId in periodIds)
            {
                var newPeriod = periods.First(p => p.Id == newPeriodId);

                foreach (var existingAlloc in existingForProject)
                {
                    var existingPeriod = existingAlloc.Period;

                    // Check if periods overlap (one contains the other)
                    bool newContainsExisting = newPeriod.StartDate <= existingPeriod.StartDate &&
                                               newPeriod.EndDate >= existingPeriod.EndDate &&
                                               newPeriod.Id != existingPeriod.Id;

                    bool existingContainsNew = existingPeriod.StartDate <= newPeriod.StartDate &&
                                               existingPeriod.EndDate >= newPeriod.EndDate &&
                                               existingPeriod.Id != newPeriod.Id;

                    if (newContainsExisting || existingContainsNew)
                    {
                        // Only add warning if not already present for this project/period combo
                        var alreadyWarned = warnings.Any(w =>
                            w.ProjectId == projectId &&
                            w.NewPeriodId == newPeriodId &&
                            w.ExistingPeriodId == existingPeriod.Id);

                        if (!alreadyWarned)
                        {
                            warnings.Add(new OverlapWarning
                            {
                                ProjectId = projectId,
                                ProjectName = projects.First(p => p.Id == projectId).Name,
                                NewPeriodId = newPeriodId,
                                NewPeriodName = newPeriod.Name,
                                ExistingPeriodId = existingPeriod.Id,
                                ExistingPeriodName = existingPeriod.Name,
                                IsNewPeriodLarger = newContainsExisting
                            });
                        }
                    }
                }
            }
        }

        return warnings;
    }

    private void CancelOverlapConfirmation()
    {
        showOverlapConfirmation = false;
        overlapWarnings.Clear();
    }

    private async Task ConfirmOverlapAndSave()
    {
        showOverlapConfirmation = false;
        overlapWarnings.Clear();
        await SaveAllocationInternal(skipOverlapCheck: true);
    }

    private async Task DeleteAllocation(Allocation allocation)
    {
        DbContext.Allocations.Remove(allocation);
        await DbContext.SaveChangesAsync();
        await LoadAllocations();
    }
}
